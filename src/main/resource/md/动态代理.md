# 动态代理

AOP代理主要分为`静态代理`和`动态代理`两大类，静态代理以 `AspectJ` 为代表；而动态代理则以 `Spring AOP` 为代表

理清概念
- JDK动态代理是模拟接口实现的方式，cglib是模拟子类继承的方式
- CGLIB动态代理是可以针对接口与普通类(继承方式),底层使用ASM框架生成字节码完成代理功能 
- AspectJ在编译期间就生成了class文件完成了代理。这点容易理解一种编译的技术
- Spring AOP集成了JDK动态代理和CGLIB动态代理, 并且支持AspectJ编程风格的AOP

JDK动态代理与CGLIB动态代理，他们的区别如下；

|类型|	机制	|回调方式|	适用场景	|效率|
|---|---|---|---|---|
|JDK	|委托机制，代理类和目标类都实现了同样的接口，InvocationHandler持有目标类，代理类委托InvocationHandler去调用目标类的原始方法|	反射	|目标类是接口类|	效率瓶颈在反射调用稍慢|
|CGLIB	|继承机制，代理类继承了目标类并重写了目标方法，通过回调函数MethodInterceptor调用父类方法执行原始逻辑	|通过FastClass方法索引调用|	非接口类，非final类，非final方法	|第一次调用因为要生成多个Class对象较JDK方式慢，多次调用因为有方法索引较反射方式快，如果方法过多switch case过多其效率还需测试| 

为了简洁明了, 一切源码分析都只挑重点代码, 如安全校验, 大部分异常抓取等都会被删除

## jdk动态代理

### 用法
```
// 实例化目标对象
UserService userService = new UserServiceForAopImpl();
// 实例化InvocationHandler
MyInvocationHandler handler = new MyInvocationHandler(userService);
// 生成代理对象
UserService proxy = (UserService) Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(), userService.getClass().getInterfaces(), handler);
```
### 源码解析

#### Proxy#newProxyInstance()
```
private static final Class<?>[] constructorParams = { InvocationHandler.class };
public static Object newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)
    // 克隆接口class
    final Class<?>[] intfs = interfaces.clone();
    // 获得代理类class
    Class<?> cl = getProxyClass0(loader, intfs);
    // 拿到代理类构造函数
    final Constructor<?> cons = cl.getConstructor(constructorParams);
    // 使用InvocationHandler作为参数实例化代理类
    return cons.newInstance(new Object[]{h});
}
```

那么接下的问题就是如何获得代理类class, jdk使用了二级缓存机制, 首先通过类加载器和接口集合去缓存里面获取，如果能找到代理类就直接返回，否则就会调用ProxyClassFactory这个工厂去生成一个代理类。先看看这个工厂类是怎样生成代理类的

#### `ProxyClassFactory`代理类工厂源码分析
```
private static final class ProxyClassFactory implements BiFunction<ClassLoader, Class<?>[], Class<?>> {
    // 代理类名称前缀
    private static final String proxyClassNamePrefix = "$Proxy";
    // 代理类序号, 以确定唯一代理类
    private static final AtomicLong nextUniqueNumber = new AtomicLong();

    @Override
    public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {
        // IdentityHashMap, key的地址值是一样的才会被判断重复
        // 用于检查接口是否重复
        Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
        for (Class<?> intf : interfaces) {
            // 这个循环里都是对intf进行校验, 故简略, 主要做三件事
            1. 判断intf是否可以由类加载器加载, 加载不了报错
            2. intf是否是一个接口, 不是接口报错
            3. intf是否由重复, 重复报错
        }
        // 代理类包名
        String proxyPkg = null;
        // 访问标志, 默认是 public final
        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

        // 这个循环的作用: 
        // 如果有一个接口的访问标志不是 public, 那么生成代理类的包名和接口名相同
        // 如果有多个接口的访问标志不是public且在不同包下, 那么报错
        for (Class<?> intf : interfaces) {
            // 获得接口访问标志
            int flags = intf.getModifiers();
            // 如果访问标志不是 public
            if (!Modifier.isPublic(flags)) {
                // 访问标志设为 final
                accessFlags = Modifier.FINAL;
                // 获得接口全限定名
                String name = intf.getName();
                int n = name.lastIndexOf('.');
                // 获得接口包名
                String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                if (proxyPkg == null) {
                    // 代理类包名和接口包名一致
                    proxyPkg = pkg;
                } else if (!pkg.equals(proxyPkg)) {
                    // 如果有多个不是public的接口且在不同包下, 那么报错
                    throw new IllegalArgumentException("non-public interfaces from different packages");
                }
            }
        }
        // 默认包名 com.sun.proxy
        if (proxyPkg == null) {
            proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
        }
        // 生成代理类序号
        long num = nextUniqueNumber.getAndIncrement();
        // 生成代理类全限定名, 如: com.sun.proxy.$Proxy0
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        // 核心代码, 用ProxyGenerator来生成字节码, 该类放在sun.misc包下
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);
        
        // 根据二进制文件生成class
        return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length);
    }
}
```

#### WeakCache代理类缓存源码分析

先看其成员变量和构造函数

```
    // Reference引用队列 TODO
    private final ReferenceQueue<K> refQueue = new ReferenceQueue<>();
    // 缓存底层实现. key可能为null所以设为Object
    // 一级缓存的key为`ClassLoader包装成的CacheKey`
    // 二级缓存的key为 
    // 二级缓存的value为          
    private final ConcurrentMap<Object, ConcurrentMap<Object, Supplier<V>>> map = new ConcurrentHashMap<>();
    //reverseMap记录了所有代理类生成器是否可用, 这是为了实现缓存的过期机制
    private final ConcurrentMap<Supplier<V>, Boolean> reverseMap = new ConcurrentHashMap<>();
    // 生成二级缓存key的工厂, 这里传入的是KeyFactory
    private final BiFunction<K, P, ?> subKeyFactory;
    // 生成二级缓存value的工厂, 这里传入的是ProxyClassFactory
    private final BiFunction<K, P, V> valueFactory;

    // 构造器, 传入生成二级缓存key的工厂和生成二级缓存value的工厂
    public WeakCache(BiFunction<K, P, ?> subKeyFactory, BiFunction<K, P, V> valueFactory) {
        this.subKeyFactory = Objects.requireNonNull(subKeyFactory);
        this.valueFactory = Objects.requireNonNull(valueFactory);
    }
```

代理类class是通过get方法返回的, 我们来分析其源码
```
//key为ClassLoader, parameter为Class<?>[]也就是接口数组, 返回为代理类class
public V get(K key, P parameter) {
    // 清除过期缓存
    expungeStaleEntries();
    // 将ClassLoader包装成CacheKey, 作为一级缓存
    Object cacheKey = CacheKey.valueOf(key, refQueue);
    // 获得二级缓存
    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);
    if (valuesMap == null) {
        // 如果二级缓存没有, 则创建后CAS放入
        ConcurrentMap<Object, Supplier<V>> oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap<>());
        // 如果CAS返回有值, 则CAS失败, 取别人放入的值
        if (oldValuesMap != null) {
            valuesMap = oldValuesMap;
        }
    }
    // 根据代理类实现的接口数组来生成二级缓存key, 分为key0, key1, key2, keyx
    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
    // 通过subkey获得二级缓存的值
    Supplier<V> supplier = valuesMap.get(subKey);
    
    Factory factory = null;
    while (true) {
        // 如果二级缓存的值不为空
        if (supplier != null) {
            // 在这里supplier可能是一个Factory也可能会是一个CacheValue
            // 在这里不作判断, 而是在Supplier实现类的get方法里面进行验证
            V value = supplier.get();
            if (value != null) {
                return value;
            }
        }
        if (factory == null) {
            //新建一个Factory实例作为subKey对应的值
            factory = new Factory(key, parameter, subKey, valuesMap);
        }

        if (supplier == null) {
            // subKey没有对应的值, 就将factory作为subKey的值放入
            supplier = valuesMap.putIfAbsent(subKey, factory);
            if (supplier == null) {
                // 成功将factory放入缓存, 那么下一次循环时就会从factory中取值 
                supplier = factory;
            }
        } else {
            // 可能被其他线程修改了二级缓存的值, 就将原先的值替换
            if (valuesMap.replace(subKey, supplier, factory)) {
                // 替换成功, 直接用新值
                supplier = factory;
            } else {
                // 替换失败, 用别的线程设置的值
                supplier = valuesMap.get(subKey);
            }
        }
    }
}
```

WeakCache的get方法的所有会进行修改的成员变量都使用了ConcurrentMap，这个类是线程安全的, 因此它将自身的线程安全委托给了ConcurrentMap。

ClassLoader作为了一级缓存的key，这样可以首先根据ClassLoader筛选一遍，因为不同ClassLoader加载的类是不同的。

然后它用接口数组来生成二级缓存的key，这里它进行了一些优化，因为大部分类都是实现了一个或两个接口，所以二级缓存key分为key0，key1，key2，keyX。key0到key2分别表示实现了0到2个接口，keyX表示实现了3个或以上的接口，事实上大部分都只会用到key1和key2。

这些key的生成工厂是在Proxy类中，通过WeakCache的构造器将key工厂传入。这里的二级缓存的值是一个Factory实例，最终代理类的值是通过Factory这个工厂来获得的。

再来看看获得代理类的Factory#get()方法:
```
private final class Factory implements Supplier<V> {
    //一级缓存key, 根据ClassLoader生成
    private final K key;
    //代理类实现的接口数组
    private final P parameter;
    //二级缓存key, 根据接口数组生成
    private final Object subKey;
    //二级缓存
    private final ConcurrentMap<Object, Supplier<V>> valuesMap;

    Factory(K key, P parameter, Object subKey,
            ConcurrentMap<Object, Supplier<V>> valuesMap) {
        this.key = key;
        this.parameter = parameter;
        this.subKey = subKey;
        this.valuesMap = valuesMap;
    }

    // 使用synchronized关键字进行了同步
    @Override
    public synchronized V get() {
        //这里再一次去二级缓存里面获取Supplier, 用来验证是否是Factory本身
        Supplier<V> supplier = valuesMap.get(subKey);
        if (supplier != this) {
            //在这里验证supplier是否是Factory实例本身, 如果不则返回null让调用者继续轮询重试
            //期间supplier可能替换成了CacheValue, 或者由于生成代理类失败被从二级缓存中移除了
            return null;
        }
        V value = null;
        try {
            //委托valueFactory去生成代理类, 这里会通过传入的ProxyClassFactory去生成代理类
            value = Objects.requireNonNull(valueFactory.apply(key, parameter));
        } finally {
            //如果生成代理类失败, 就将这个二级缓存删除
            if (value == null) {
                valuesMap.remove(subKey, this);
            }
        }
        //只有value的值不为空才能到达这里
        assert value != null;
        //使用弱引用包装生成的代理类
        CacheValue<V> cacheValue = new CacheValue<>(value);
        //将包装后的cacheValue放入二级缓存中, 这个操作必须成功, 否则就报错
        if (valuesMap.replace(subKey, this, cacheValue)) {
            //将cacheValue成功放入二级缓存后, 再对它进行标记
            reverseMap.put(cacheValue, Boolean.TRUE);
        } else {
            throw new AssertionError("Should not reach here");
        }
        //最后返回没有被弱引用包装的代理类
        return value;
    }
}
```

首先会去验证subKey对应的suppiler是否是工厂本身，如果不是就返回null，而WeakCache的get方法会继续进行重试。如果确实是工厂本身，那么就会委托ProxyClassFactory生成代理类.

生成代理类后会通过CAS将二级缓存的值由Factory实例变为代理类Class的CacheValue, 并使用弱引用进行包装并放入reverseMap中，最后会返回原装的代理类。

TODO: 不过有一点不明白, 为什么要先生成Factory, 通过Factory获得代理类后替换, 而不是直接获得代理类, 放入二级缓存呢?


### 字节码文件的最终生成: ProxyGenerator

具体源码就不分析了, 都是添加构造器, 方法, 字段的代码. 具体可以看`ProxyGenerator#generateClassFile`

贴下最终的代理类结构:
```
public class Proxy0 extends Proxy implements UserDao {
    //第一步, 生成构造器
    protected Proxy0(InvocationHandler h) {
        super(h);
    }
    //第二步, 生成静态域
    private static Method m1;   //hashCode方法
    private static Method m2;   //equals方法
    private static Method m3;   //toString方法
    private static Method m4;   //...
    //第三步, 生成代理方法
    @Override
    public int hashCode() {
        try {
            return (int) h.invoke(this, m1, null);
        } catch (Throwable e) {
            throw new UndeclaredThrowableException(e);
        }
    }
    @Override
    public boolean equals(Object obj) {
        try {
            Object[] args = new Object[] {obj};
            return (boolean) h.invoke(this, m2, args);
        } catch (Throwable e) {
            throw new UndeclaredThrowableException(e);
        }
    }
    @Override
    public String toString() {
        try {
            return (String) h.invoke(this, m3, null);
        } catch (Throwable e) {
            throw new UndeclaredThrowableException(e);
        }
    }
    @Override
    public void save(User user) {
        try {
            //构造参数数组, 如果有多个参数往后面添加就行了
            Object[] args = new Object[] {user};
            h.invoke(this, m4, args);
        } catch (Throwable e) {
            throw new UndeclaredThrowableException(e);
        }
    }
    //第四步, 生成静态初始化方法
    static {
        try {
            Class c1 = Class.forName(Object.class.getName());
            Class c2 = Class.forName(UserDao.class.getName());    
            m1 = c1.getMethod("hashCode", null);
            m2 = c1.getMethod("equals", new Class[]{Object.class});
            m3 = c1.getMethod("toString", null);
            m4 = c2.getMethod("save", new Class[]{User.class});
            //...
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
至此, JDK动态代理源码分析完毕, 但是纸上得来终觉浅，想要更好的掌握JDK动态代理技术, 还得多多实践, 多多交流学习心得，，共同学习，共同进步。

## cglib动态代理

暂时没有发现写的很好的源码分析文章, 自己看也看的不是很明白, 故这里只贴一下代理类源码, 并对代理类源码做分析

### 执行流程：

Callback为MethodInterceptor时:
- 调用代理类方法。
- 代理类方法中触发拦截器方法。
- 拦截器中触发MethodProxy.invokeSuper方法，并获取需要调用的代理类方法索引。
- 执行Fast索引类方法，根据代理类方法索引，获得代理类方法。
- 执行代理类中代理方法，通过super()方法完成真实逻辑调用。

### 不同的Callback对生成代理类的影响

先对每种Callback代理类不同的地方做个对比, 讲清逻辑, 再分析下它们相同的地方

#### Dispatcher
```
private Dispatcher CGLIB$CALLBACK_0;
public final void save(User var1) {
    Dispatcher var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        // 延迟加载策略, 所有Callback(除了NoOp)的所有方法都是这样
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    // 调用loadObject()方法获得真正的代理对象, 再调用代理对象的方法
    ((UserServiceForAopImpl)var10000.loadObject()).save(var1);
}
```

#### LazyLoader
```
private LazyLoader CGLIB$CALLBACK_0;
// 代理类的缓存
private Object CGLIB$LAZY_LOADER_0;

public final void save(User var1) {
    // 获得代理类的缓存, 调用其方法
    ((UserServiceForAopImpl)this.CGLIB$LOAD_PRIVATE_0()).save(var1);
}

private final synchronized Object CGLIB$LOAD_PRIVATE_0() {
    Object var10000 = this.CGLIB$LAZY_LOADER_0;
    if (var10000 == null) {
        // 如果被代理类的缓存为空, 则加载缓存
        LazyLoader var10001 = this.CGLIB$CALLBACK_0;
        if (var10001 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10001 = this.CGLIB$CALLBACK_0;
        }

        var10000 = this.CGLIB$LAZY_LOADER_0 = var10001.loadObject();
    }
    // 如果有缓存则直接返回, 不会重复调用loadObject()方法
    return var10000;
}
```
#### FixedValue

这个FixedValue测试类中注册了两个callback, 并注册了过滤器, 令人没想到的是竟然不是在代理类中调用过滤器选择callback, 而是在生成字节码之前就已经调用过过滤器.

```
// 第0位callback
private FixedValue CGLIB$CALLBACK_0;
// 第1位callback
private FixedValue CGLIB$CALLBACK_1;
public final void save(User var1) {
    FixedValue var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    // 直接调用callback的loadObject, 和被代理类原方法无关
    var10000.loadObject();
}

public final List listUser() {
    FixedValue var10000 = this.CGLIB$CALLBACK_1;
    if (var10000 == null) {
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_1;
    }

    return (List)var10000.loadObject();
}
```
### InvocationHandler

这个callback不但类名,方法名,方法签名都和jdk动态代理一样, 连实现都一样

### NoOp
继承被代理类之后, 啥也不干, 不重写其方法.

### MethodInterceptor

最常用也是最复杂的callback, 会生成三个class, 一个代理类, 两个作为索引的fastclass

这里我们追踪save方法看看MethodInterceptor是怎么工作的.先直接查看被代理类的save方法

```
// 由于我注册了两个MethodInterceptor所以这里有两个MethodInterceptor变量
private MethodInterceptor CGLIB$CALLBACK_0;
private MethodInterceptor CGLIB$CALLBACK_1;
// 
private static final Method CGLIB$save$0$Method;
private static final MethodProxy CGLIB$save$0$Proxy;
static {
    // class加载时初始化 Method 及 MethodProxy
    CGLIB$STATICHOOK1();
}
static void CGLIB$STATICHOOK1() {
    // var0就是当前的代理类
    Class var0 = Class.forName("xl.test.framework.springboot.aop.proxy.UserServiceForAopImpl$$EnhancerByCGLIB$$bde8450b");
    // 这里看起来var1是空, 实际上是反编译器的问题, debug时可以看到var1时被代理类class
    Class var1;
    // 获得被代理类的方法
    Method[] var10000 = ReflectUtils.findMethods(new String[]{"save", "(Lxl/test/common/entity/User;)V", "listUser", "()Ljava/util/List;"}, (var1 = Class.forName("xl.test.framework.springboot.aop.proxy.UserServiceForAopImpl")).getDeclaredMethods());
    CGLIB$save$0$Method = var10000[0];
    // 创建代理类 MethodProxy
    CGLIB$save$0$Proxy = MethodProxy.create(var1, var0, "(Lxl/test/common/entity/User;)V", "save", "CGLIB$save$0");
}
public final void save(User var1) {
    MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
    if (var10000 == null) {
        // 延迟加载MethodInterceptor
        CGLIB$BIND_CALLBACKS(this);
        var10000 = this.CGLIB$CALLBACK_0;
    }
    // 好像也不复杂,有callback调用callback, 没callback调用原方法
    if (var10000 != null) {
        var10000.intercept(this, CGLIB$save$0$Method, new Object[]{var1}, CGLIB$save$0$Proxy);
    } else {
        super.save(var1);
    }
}
```
就这样完了吗? 不, 还没完, 再看看我们在MethodInterceptor中调用实例的
```
// 调用代理类实例上的proxy方法的父类方法，即被代理对象中的方法
Object result = methodProxy.invokeSuper(target, args);
```
这么调用是因为其能直接调用被代理的方法, 而不是反射调用, 速度比反射调用快, 那么, 为什么这么调用能直接调用被代理的方法?

```
// 在构造方法里 createInfo = new CreateInfo(c1, c2); 其中c1是被代理类Class, c2是代理类Class
private CreateInfo createInfo;
private volatile FastClassInfo fastClassInfo;
public Object invokeSuper(Object obj, Object[] args) throws Throwable {
    // 这里其实就是初始化 fastClassInfo
    init();
    FastClassInfo fci = fastClassInfo;
    return fci.f2.invoke(fci.i2, obj, args);
}
private void init() {
    // 双重锁定构造fastClassInfo
    if (fastClassInfo == null) {
        synchronized (initLock) {
            if (fastClassInfo == null) {
                CreateInfo ci = createInfo;
                // 创建fastClassInfo
                FastClassInfo fci = new FastClassInfo();
                // 这里会创建被代理类的fastclass, 并赋值给fci.f1, ci.c1就是上文的var0
                fci.f1 = helper(ci, ci.c1);
                // 这里会创建被理类的fastclass, 并赋值给fci.f1, ci.c2就是上文的var1
                fci.f2 = helper(ci, ci.c2);
                // 获得当前MethodProxy所代理的被代理类方法的索引
                fci.i1 = fci.f1.getIndex(sig1);
                // 获得当前MethodProxy所代理的代理类方法的索引
                fci.i2 = fci.f2.getIndex(sig2);
                fastClassInfo = fci;
                createInfo = null;
            }
        }
    }
}
```
`invokeSuper()`方法最后使用`FastClassInfo.f2`参数的`invoke()`方法, 把注意力转向`FastClassInfo`, 可以看到`FastClassInfo`的构造依赖于`CreateInfo`, 因此, 我们看看CreateInfo创建的地方, 其实就是MethodProxy创建的地方
```
// 此方法在MethodProxy中
public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {
    MethodProxy proxy = new MethodProxy();
    // 生成被代理类方法签名, 用于获得方法的索引
    proxy.sig1 = new Signature(name1, desc);
    // 生成被被代理类方法签名, 用于获得方法的索引
    proxy.sig2 = new Signature(name2, desc);
    // 这里可以看到CreateInfo就是用于存储被代理类class和代理类class
    proxy.createInfo = new CreateInfo(c1, c2);
    return proxy;
}
```

我们已经获得了代理类的fastclass`FastClassInfo.f2`及要调用方法的索引`FastClassInfo.i2`, 可以调用fastclass的invoke()方法:
```
public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
    // 编译器问题, 其实强转成代理类class
    36376ee1 var10000 = (36376ee1)var2;
    // 索引
    int var10001 = var1;
    // 只列出被代理类中的方法
    switch(var10001) {
    case 21:
        // 可以看到调用的是代理类的 CGLIB$save$0 方法
        var10000.CGLIB$save$0((User)var3[0]);
        return null;
    case 22:
        return var10000.CGLIB$listUser$1();
    }
    throw new IllegalArgumentException("Cannot find matching method/constructor");
}
// 回到代理类class查看CGLIB$save$0方法, 发现这是代理类新生成的一个final方法, 直接调用了被代理类
final void CGLIB$save$0(User var1) {
    super.save(var1);
}
```
至此, 我们终于明白为什么`methodProxy.invokeSuper(target, args);`能够直接调用被代理类中的方法.

然而, 还有一个疑问, MethodProxy#init()方法中, 还初始化了被代理类的fastclass, 这在整个流程中并没有用到, 那么, 这个fastclass有什么用呢? 往下看

### MethodInterceptor的两种调用方法
在MethodInterceptor中, 有两种调用被代理类的方法, 如果算上反射, 则有三种
```
// 第一种, invokeSuper(), 只需传入代理类和调用参数
Object result = methodProxy.invokeSuper(target, args);
// 第二种, invoke. 需要一个被代理类实例
Object result = methodProxy.invoke(new UserServiceForAopImpl(), args);
// 第三种, 普通的jdk反射, 这里不讨论
Object result = method.invoke(new UserServiceForAopImpl(), args);
```

跟踪源码, 很容易发现`methodProxy.invokeSuper()`使用的是`fci.f2.invoke()`最后调用`super.save()`来执行调用的方法

而`methodProxy.invoke()`使用的是`fci.f1.invoke()`, 也就是调用了被代理类的fastclass, 我们看它的源码:
```
public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
    UserServiceForAopImpl var10000 = (UserServiceForAopImpl)var2;
    int var10001 = var1;
    switch(var10001) {
    case 0:
        // 直接调用了传入实例的方法
        var10000.save((User)var3[0]);
        return null;
    }
    throw new IllegalArgumentException("Cannot find matching method/constructor");
}
```
也就是说, cglib把静态代理与动态代理合二为一, 使用`methodProxy.invokeSuper()`的是静态代理,而使用`methodProxy.invoke()`是动态代理
最后, 我们对两种调用做个对比

|调用方法|方法传入obj参数|fastclass|被代理类限制|                                                                                                                                                                                    
|---|---|---|---|
|methodProxy.invokeSuper()|代理类实例,由callback方法传入|生成的代理类的fastclass|被代理类必须是实现类|
|methodProxy.invoke()|被代理类实例, 可以自行创建多个并调用多次|被代理类的fastclass|被代理类可以是接口|

## 附录
- https://www.cnblogs.com/liuyun1995/p/8144628.html
- https://juejin.im/post/5db7870a518825647178f16c
- https://www.jianshu.com/p/2aadb53662cf
- https://www.jianshu.com/p/001f866a49d7
- https://www.cnblogs.com/aspirant/p/8796974.html
