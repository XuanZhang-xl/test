# 数据密集型应用系统设计 笔记


## 概念
- 事务 一个抽象层, 一组sql语句要么全部成功要么全部失败, 目的是为了封装底层的复杂性
- 赃读 读取到了其他事务未提交的数据
- 脏写 覆盖了其他事务未提交的写入
- 读倾斜(不可重复读) 事务在不同的时间点读到了了不同的值
- 幻读, 有三种意义, 只读查询幻读, 以及 读-写幻读
    - 只读查询幻读: 读取到了其他事务插入的数据, rr级隔离级别可以防止, 感觉就是不可重复度
    - 写幻读: 查不到指定主键的数据, 插入指定主键的数据时, 这个主键已经被其他事务所用, 导致插入失败, 由于主键都是自增一般不会出现
    - 读-写幻读(写倾斜): 一个事务中的写入改变了另一个事务查询结果, 快照隔离级别只能避免只读查询的幻读, rr级加 for update可以防止
- 更新丢失 两事务并发执行读取-修改-写入, 一个事务覆盖了另一个事务, 没有包含另一个事务的更新
    - 防止更新丢失的手段:
    - 原子性操作  update set a = a + 1
    - 显式加锁, 悲观锁  select ... for update
    - 自动检测更新丢失  乐观锁  然而很遗憾, mysql不支持自动检测
- 写倾斜 广义的更新丢失, 两个事务读取同一组对象, 分别更新其中的一部分, 更新操作会影响之前的读取操作,实际上是不能同时更新成功的. 由于写倾斜而导致幻读
    - 显式加锁  select ... for update
    - 两阶段加锁(2PL) 容易[死锁](#1), 很少使用
    - 串行化的快照隔离(自动检测更新丢失)  然而很遗憾, mysql不支持自动检测
- OLTP/OLAP 
    -   OLTP online transaction processing
    -   OLAP online analytic processing
    -   |属性|事务处理系统(OLTP)|分析系统(OLAP)|
        |---|---|---|
        |主要读特征|基于键, 每次查询返回少量记录|对大量数据进行汇总|
        |主要写特征|随机访问, 低延迟写入用户的输入|批量导入(ETL)或事件流|
        |典型使用场景|终端用户, 通过网络应用程序|内部分析师, 为决策提供支持|
        |数据表征|最新的数据状态|随着时间而变化的所有事件历史|
        |数据规模|GB到TB|TB到PB|
    
    
    
## MVCC与redo/undo

mysql使用redo/undo来实现MVCC

Multi-Version Concurrency Control, 对数据库的任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存，使得读取时可以完全不加锁。
```
MVCC实现:
每个数据记录携带两个额外的数据created_by_txn_id和deleted_by_txn_id。
当一个数据被insert时，created_by_txn_id记录下插入该数据的事务ID，deleted_by_txn_id留空。
当一个数据被delete时，该数据的deleted_by_txn_id记录执行该删除的事务ID。
当一个数据被update时，原有数据的deleted_by_txn_id记录执行该更新的事务ID，并且新增一条新的数据记录，其created_by_txn_id记录下更新该数据的事务ID
在另一个事务进行读取时，由隔离级别来控制到底取哪个版本。同时，在读取过程中，完全不加锁（除非用SELECT … FOR UPDATE强行加锁）

有了MVCC，Read Committed和Repeatable Read就的实现就很直观了：
对于Read Committed，每次读取时，总是取最新的，被提交的那个版本的数据记录。
对于Repeatable Read，每次读取时，总是取created_by_txn_id小于等于当前事务ID的那些数据记录。在这个范围内，如果某一数据多个版本都存在，则取最新的。

作者：大宽宽
链接：https://www.jianshu.com/p/cb97f76a92fd
```

## 索引
- 聚簇索引
- 非聚簇索引
- 二级索引 mysql二级索引为非聚簇索引, 
- 联合索引(也叫多列索引, 级联索引)
- 覆盖索引

## ACID
- Atomicity，原子性。很令人郁闷的是，这个词表达意思与常规语境下不太一样。
对于一门支持并发的编程语言（比如Java，C++），原子性是指一组指令被执行时，不受其他指令的干扰。
比如我们可以说“CAS是原子的；给一个整型变量赋值是原子的”等等。但是在ACID语境下，“不受干扰”这层意思其实是后边“隔离性“说的事情。
在ACID语境下，原子性是指一组对数据库的改变，要么最终成功执行完成，要不就全部回滚。这就要求数据库系统要实现某种回滚的机制，比如redo/undo log）。
所以，也许这里用术语”revertability“可能更适合。与事务性数据库相比，一些NoSQL的数据库也声称支持原子性，但是意义不同。
比如Redis事务的原子性的意思可能更接近于“一组指令被执行时，不受其他指令的干扰”，而不是“可以回滚”。

- Consistency, 一致性。这个术语的用词也颇为怪异。一般来讲，我们习惯用“一致性”来描述数据在某些条件下可以变成一样的。
例如，在描述CPU工作方式时可以说需要主内存在CPU Core1里的缓存和CPU Core2里的缓存是“一致的“；或者，一个分布式数据系统中，A节点从B节点复制数据，A的数据要和B的数据"严格一致"或者“最终一致”。
而ACID下的一致性指的是，在事务完成前后，数据都是要在业务意义上是”正确的“，所以也许术语”correctness“更适合这里的意思。
但如果这样定义的话，数据库的位置就很尴尬了，因为保证业务是否正确是要业务代码来最终保证的，数据库能做的非常有限。
目前数据库里实现的约束检查，比如唯一约束、外键约束、一些enum测检查、一些数据类型/长度/有效数字的检查等等，对于简单的场景还可以使用。
对于复杂的业务约束检查，很难或者不可能实现。有一类数据正确性问题正是由于下面隔离性的使用不当而带来的。 
真实复杂业务的数据正确性维护一般用正确的业务代码 + 合法性job来定时执行 + 数据库自身的简单合法性防护一起实现。

- Isolation，隔离性。是指一组对数据库的并发修改互相不影响。
这个概念表面上看来并不是能说得通，因为如果并发修改的是互不相干的数据，那么自然隔离性可以得到满足；如果并发修改的是相关联的，或者就是同一份数据，就必然会相互影响。
那么，此时可以做的就是区分哪个修改优先级更加高。而高优先级的修改应该覆盖掉低优先级的修改。
但是，现实往往更复杂，因为并发的修改并不一定能够讲明白先来后到的（要不怎么叫并发呢），此时谁应该生效无法很好的定义。
另外一种情况是“先读取，再基于读取结果对数据进行修改”这样业务逻辑。比如，先找到可用的库存，有则扣减，没有则提示缺货；再比如先读取当前的计数值，再往上加1。
这时保证隔离性的主要问题不在于隔离本身，而在于如果将读取作为对数据修改的前提条件，之后在对数据进行修改的一刹那，读取时的前提条件还是否满足。
毕竟读取和写入是两个分开的指令，而在这两个指令中间可能夹杂其他事务对数据的修改。保持隔离性的一个简单做法是保证对关联数据的修改串行化，对应事务性数据库的“Serializable”隔离级别。
保证串行化的一种方案是锁，通过锁定可以彻底避免竞争条件。但是大家都能明白加锁对数据库并发的性能负面影响很大，所以就衍生出了几种弱一些的隔离性保证——READ UNCOMMITTED, READ COMMITTED, REPEATABLE READ。
此外MVCC能够解决一部分锁带来的问题。这些内容在下文中会详细的讲解。

- Duration，持久性。是指对数据的修改，一旦完成，该结果就应当永远不丢失。这是这4个术语中我唯一觉得表面上和实际上意思差不多的一条。
在现实当中，一般通过持久性存储设备（比如磁盘/SSD）写入并刷新来保证数据的持久性。如果觉得一个节点不靠谱，可以增加多个副本（replica）一起来保证持久；如果觉得这样还不够靠谱，可以在不同的地理位置的另一个数据中心做备份。
实际上绝对的持久性是不存在的，因为整个存储层面有很多不确定因素，比如文件系统本身fsync指令实现有bug，磁盘的固件有bug，供电出现问题造成数据错乱，异步的数据复制没有生效等等。
所以在现实当中的数据库，只能在当前成本和技术限制的约束下，尽量维持一定程度的持久性。


所以这么整理起来。实际上事务性数据库实现的是
- 支持未完成的数据修改回滚的机制，对应“原子性”
- 力所能及的数据合法性检查，对应“一致性”
- 保证数据并发的修改的规则，对应“隔离性”
- 使用基于持久化存储（磁盘、SSD）的方式对数据进行存储，对应“持久性”
    
    

## 隔离级别
|隔离级别 |	MySQL |	PostgreSQL|
|---|---|---|
|Read Uncommitted |	支持 |	不支持，等价于Read Committed|
|Read Committed |	支持，基于MVCC实现 |	支持，基于MVCC实现|
|Repeatable Read |	支持，基于MVCC实现了Snapshot Isolation，可避免幻读 |	支持，基于MVCC实现了Snapshot Isolation，可避免幻读|
|Serializable |	支持，Repeatable Read + 共享锁 |	支持，基于MVCC实现了Serialized Snapshot Isolation|
|默认级别 |	Repeatable Read |	Read Committed|
|MVCC实现 |	基于Undo Log |	基于B+树直接记录多个版本|

这里 MySQL的Repeatable Read 可避免幻读, 避免的是只读查询幻读

而PostgreSQL的Repeatable Read由于支持了SSI, 可同时避免三种幻读


## TODO
-   如果TCP连接中断, 则事务也必须终止 p218
-   谓词锁 p244
-   读事务 `SET TRANSACTION READ ONLY` 多条统计语句不会受到其他事务的影响



## 附录

|事务A|事务B|
|---|---|
|BEGIN;|BEGIN;|
|SELECT * FROM A;| |
| |SELECT * FROM A;|
|UPDATE A.a = 1; 等待事务B释放读锁| |
| |UPDATE A.a = 2; 等待事务A释放读锁|

<span id="1">Mysql Serializable隔离级别下死锁示例</span>

