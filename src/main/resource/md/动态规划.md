# 动态规划(DYNAMIC PROGRAMMING)题目

## 1. 正则表达式匹配

### 说明
> 链接：https://leetcode-cn.com/problems/regular-expression-matching

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

```
'.' 匹配任意单个字符
'*' 匹配零个或多个前面的那一个元素
```


所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。

说明:
- `s` 可能为空，且只包含从 `a-z` 的小写字母。
- `p` 可能为空，且只包含从 `a-z` 的小写字母，以及字符`.` 和 `*`。

示例 1:
```
输入:
s = "aa"
p = "a"
输出: false
解释: "a" 无法匹配 "aa" 整个字符串。
```
示例 2:
```
输入:
s = "aa"
p = "a*"
输出: true
解释: 因为 '*' 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 'a'。因此，字符串 "aa" 可被视为 'a' 重复了一次。
```
示例 3:
```
输入:
s = "ab"
p = ".*"
输出: true
解释: ".*" 表示可匹配零个或多个（'*'）任意字符（'.'）。
```
示例 4:
```
输入:
s = "aab"
p = "c*a*b"
输出: true
解释: 因为 '*' 表示零个或多个，这里 'c' 为 0 个, 'a' 被重复一次。因此可以匹配字符串 "aab"。
```
示例 5:
```
输入:
s = "mississippi"
p = "mis*is*p*."
输出: false
```

### 解析

> 链接：https://leetcode-cn.com/problems/regular-expression-matching/solution/dong-tai-gui-hua-zen-yao-cong-0kai-shi-si-kao-da-b/

**状态**

首先状态 dp 一定能自己想出来。
`dp[i][j]` 表示 `s` 的前 i 个是否能被 `p` 的前 j 个匹配

**转移方程**

怎么想转移方程？首先想的时候从已经求出了 `dp[i-1][j-1]` 入手，再加上已知 `s[i]`、`p[j]`，要想的问题就是怎么去求 `dp[i][j]`。

已知 `dp[i-1][j-1]` 意思就是前面子串都匹配上了，不知道新的一位的情况。
那就分情况考虑，所以对于新的一位 p[j] s[i] 的值不同，要分情况讨论：

1. 考虑最简单的`p[j]==s[i]`:`dp[i][j]=dp[i-1][j-1]` 然后从`p[j]`可能的情况来考虑，让`p[j]=各种能等于的东西`。

2. `p[j] == "." : dp[i][j] = dp[i-1][j-1]`

3. `p[j] =="*":`

**第一个难想出来的点：怎么区分`*`的两种讨论情况**

首先给了`*`，明白`*`的含义是匹配零个或多个前面的那一个元素，所以要考虑他前面的元素`p[j-1]`。`*`跟着他前一个字符走，前一个能匹配上 `s[i]`，`*`才能有用，前一个都不能匹配上 `s[i]`，`*` 也无能为力，只能让前一个字符消失，也就是匹配0次前一个字符。
所以按照 `p[j-1]` 和 `s[i]` 是否相等，我们分为两种情况：

3.1 `p[j-1] != s[i] : dp[i][j] = dp[i][j-2]`
- 这就是刚才说的那种前一个字符匹配不上的情况。
- 比如`(ab, abc * )`。遇到 `*` 往前看两个，发现前面 `s[i]` 的 `ab` 对 `p[j-2]` 的 `ab` 能匹配，虽然后面是 `c*`，但是可以看做匹配 0 次 c，相当于直接去掉 `c*`，所以也是 True。注意 `(ab, abc**)` 是 False。

3.2 `p[j-1] == s[i] or p[j-1] == "."`
- `*`前面那个字符，能匹配 `s[i]`，或者 `*` 前面那个字符是万能的 `.`
- 因为 `.*` 就相当于 `..`，那就只要看前面可不可以匹配就行。
- 比如 `(##b , ###b*)`，或者 `( ##b , ###.* )` 只看 `###` 后面一定是能够匹配上的。
- 所以要看 `b` 和 `b*` 前面那部分 `##` 的地方匹不匹配。

**第二个难想出来的点：怎么判断前面是否匹配**
```
dp[i][j] = dp[i-1][j] // 忽略s的第i个元素看是否匹配, 如果匹配, 则由于*的存在, 不妨多一个与第i-1个元素一样的第i个元素, 也就是当*代表重复多次的情况
dp[i][j] = dp[i][j-1] // 忽略p的第j个元素看是否匹配, 也就是忽略*, 也就是当*代表一次的情况
dp[i][j] = dp[i][j-2] // 忽略p的第j及j-1个元素看是否匹配, 也就是当*代表零次的情况
```

看 `###` 匹不匹配，不是直接只看 `###` 匹不匹配，要综合后面的 `bb*` 来分析

这三种情况是 or 的关系，满足任意一种都可以匹配上，同时是最难以理解的地方：
- `dp[i-1][j]` 就是看 `s` 里 `b`多不多， `###` 和 `###b*` 是否匹配，一旦匹配，`s` 后面再添个 `b` 也不影响，因为有 `*` 在，也就是 `###b` 和 `###b*`也会匹配。
- `dp[i][j-1]` 就是去掉 `*` 的那部分，`###b` 和 `###b` 是否匹配，比如 `qqb` `qqb`
- `dp[i][j-2]` 就是 去掉多余的 `b*`，`p` 本身之前的能否匹配，`###b` 和 `###` 是否匹配，比如 `qqb` `qqbb*` 之前的 `qqb` `qqb` 就可以匹配，那多了的 `b*` 也无所谓，因为 `b*` 可以是匹配 0 次 `b`，相当于 `b*` 可以直接去掉了。

三种满足一种就能匹配上。

为什么没有 `dp[i-1][j-2]` 的情况？ 就是 `###` 和 `###` 是否匹配？因为这种情况已经是 `dp[i][j-1]` 的子问题。也就是 `s[i]==p[j-1]`，则 `dp[i-1][j-2]=dp[i][j-1]`。

**最后来个归纳**
- 如果 `p.charAt(j) == s.charAt(i) : dp[i][j] = dp[i-1][j-1]`；
- 如果 `p.charAt(j) == '.' : dp[i][j] = dp[i-1][j-1]`；
- 如果 `p.charAt(j) == '*'`：
    - 如果 `p.charAt(j-1) != s.charAt(i) : dp[i][j] = dp[i][j-2]` //in this case, a* only counts as empty
    - 如果 `p.charAt(i-1) == s.charAt(i) or p.charAt(i-1) == '.'`：
        - `dp[i][j] = dp[i-1][j]` //in this case, a* counts as multiple a
        - or `dp[i][j] = dp[i][j-1]` // in this case, a* counts as single a
        - or `dp[i][j] = dp[i][j-2]` // in this case, a* counts as empty
        
### 实现
```
xl.test.algorithm.leetcode.PatternLeetcode
```


## 2. 鸡蛋掉落

### 说明
> 链接: https://leetcode-cn.com/problems/super-egg-drop/

你将获得 `K` 个鸡蛋，并可以使用一栋从 `1` 到 `N`  共有 `N` 层楼的建筑。

每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。

你知道存在楼层 `F` ，满足 `0 <= F <= N` 任何从高于 `F` 的楼层落下的鸡蛋都会碎，从 `F` 楼层或比它低的楼层落下的鸡蛋都不会破。

每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 `1 <= X <= N`）。

你的目标是确切地知道 `F` 的值是多少。

无论 `F` 的初始值如何，你确定 `F` 的值的最小移动次数是多少？

示例 1：
```
输入：K = 1, N = 2
输出：2
解释：
鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。
否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。
如果它没碎，那么我们肯定知道 F = 2 。
因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。
```

示例 2：

```
输入：K = 2, N = 6
输出：3
```
示例 3：
```
输入：K = 3, N = 14
输出：4
```

### 解析
很容易想到用动态规划来做这道题。

状态可以表示成 `(K, N)`: `K` 为鸡蛋数和 `N` 为楼层数。当从第 `X` 楼扔鸡蛋的时候，要么鸡蛋不碎，状态变成 `(K, N-X)`，或者碎掉，状态变成 `(K-1, X-1)`。

定义 `dp(K, N)` 为状态 `(K, N)` 下最多需要的步数。根据以上分析：

```
dp(K, N) = min(
    max(
        dp(K-1, X-1), 
        dp(K, N-X)
    )
)
其中: 1≤X≤N
```

时间复杂度为 `O(K N^2)`

**优化**
`dp(K,N)` 是一个关于 `N` 的递增函数。
在最大式中，第一项 `T1 = dp(K-1, X-1)` 是一个随 `X` 递增的函数，第二项 `T2 = dp(K, N-X)` 是一个随着 `X` 递减的方法。

![](../img/superEggDrop.png)

也就是说, 只需要找到`X0`与`X1`, 比较`X0`与`X1`下的`max(T1, T2)`, 取小的那个`max(T1, T2)`即为答案

**如何找到X0与X1?**
将`X`从`0`开始遍历, 如果`max(dp(X), dp(N-X)) < max(dp(X + 1), dp(N- (X + 1)))` 则`X0`或`X1`等于`max(dp(X), dp(N-X))`, 无论`X=X0`还是`X1`, 这都已经是最佳答案了.

时间复杂度： `O(K∗N)`。// WHY? 怎么看都是`O(KN^2)`

**换个思路**

上面的方法的思路，都还是顺着题目的思路的进行的，其实我们可以换一个思路来想：“求`k`个鸡蛋在`m`步内可以测出多少层”。
我们令`dp[k][m]`表示`k`个鸡蛋在`m`步内可以测出的最多的层数，那么当我们在第`X`层扔鸡蛋的时候，就有两种情况：
- 鸡蛋碎了，我们少了一颗鸡蛋，也用掉了一步，此时测出`N - X + dp[k-1][m-1]`层，`X`和它上面的`N-X`层已经通过这次扔鸡蛋确定大于`F`；
- 鸡蛋没碎，鸡蛋的数量没有变，但是用掉了一步，剩余`X + dp[k][m-1]`，`X`层及其以下已经通过这次扔鸡蛋确定不会大于`F`；

也就是说，我们每一次扔鸡蛋，不仅仅确定了下一次扔鸡蛋的楼层的方向，也确定了另一半楼层与F的大小关系，所以在下面的关键代码中，使用的不再是max，而是加法（这里是重点）。

评论里有人问到为什么是相加，其实这里有一个惯性思维的误区，上面的诸多解法中，往往求max的思路是“两种方式中较大的那一个结果”，其实这里的相加，不是鸡蛋碎了和没碎两种情况的相加，而是“本次扔之后可能测出来的层数 + 本次扔之前已经测出来的层数”。


https://leetcode.com/articles/super-egg-drop/#

### 实现
```
xl.test.algorithm.leetcode.ThrowEggs
```

## 3. 

### 说明
### 解析
### 实现